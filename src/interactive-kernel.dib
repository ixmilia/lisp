#!csharp

#r "../artifacts/bin/IxMilia.Lisp/Debug/netstandard1.3/IxMilia.Lisp.dll"

#!csharp

using System.Threading.Tasks;
using IxMilia.Lisp;
using Microsoft.CodeAnalysis;
using Microsoft.DotNet.Interactive;
using Microsoft.DotNet.Interactive.Commands;
using Microsoft.DotNet.Interactive.Events;

class LispKernel :
    Kernel,
    IKernelCommandHandler<RequestHoverText>,
    IKernelCommandHandler<SubmitCode>
{
    private LispRepl _repl;

    public LispKernel()
        : base("lisp")
    {
        _repl = new LispRepl(location: "*REPL*");
    }

    public Task HandleAsync(RequestHoverText command, KernelInvocationContext context)
    {
        var obj = _repl.GetObjectAtLocation(command.Code, new LispSourcePosition(command.LinePosition.Line + 1, command.LinePosition.Character + 1));
        if (obj != null)
        {
            var markdown = _repl.GetMarkdownDisplayFromSourceObject(obj);
            if (markdown != null)
            {
                LinePositionSpan span = null;
                var formatted = new FormattedValue("text/markdown", markdown);
                if (obj.SourceLocation.HasValue)
                {
                    span = new LinePositionSpan(
                        new LinePosition(obj.SourceLocation.Value.Start.Line - 1, obj.SourceLocation.Value.Start.Column - 1),
                        new LinePosition(obj.SourceLocation.Value.End.Line - 1, obj.SourceLocation.Value.End.Column - 1)
                    );
                }

                context.Publish(new HoverTextProduced(command, new[] { formatted }, span));
            }
        }

        return Task.CompletedTask;
    }

    public Task HandleAsync(SubmitCode command, KernelInvocationContext context)
    {
        var result = _repl.Eval(command.Code, consumeIncompleteInput: false);
        switch (result.ExecutionState.LastResult)
        {
            case LispError err:
                var errorLocation = err.SourceLocation;
                Console.WriteLine($"stack frame: {err.StackFrame}");
                var replFrame = err.StackFrame;
                while (replFrame != null)
                {
                    if (replFrame.SourceLocation?.FilePath == "*REPL*")
                    {
                        errorLocation = replFrame.SourceLocation;
                        break;
                    }

                    replFrame = replFrame.Parent;
                }

                if (errorLocation != null)
                {
                    var diag = new Microsoft.DotNet.Interactive.Diagnostic(
                        new LinePositionSpan(
                            new LinePosition(errorLocation.Value.Start.Line - 1, errorLocation.Value.Start.Column - 1),
                            new LinePosition(errorLocation.Value.End.Line - 1, errorLocation.Value.End.Column - 1)),
                        DiagnosticSeverity.Error,
                        "LISP0001",
                        err.Message);
                    context.Publish(new DiagnosticsProduced(new[] { diag }, command));
                }

                context.Fail(command, null, err.Message);
                break;
            case LispObject obj:
                var formatted = new FormattedValue("text/plain", obj.ToString()); // TODO: return strings, ints, etc.
                context.Publish(new ReturnValueProduced(obj, command, new[] { formatted }));
                context.Publish(new DiagnosticsProduced(new Microsoft.DotNet.Interactive.Diagnostic[0], command));
                break;
        }

        return Task.CompletedTask;
    }
}

((CompositeKernel)Kernel.Root.RootKernel).Add(new LispKernel());

#!csharp

#!lisp
(defun add (a b)
    "Adds two numbers."
    (+ a b))
(format t "hello")
(setf sum (add 1 2))
sum
