(defun assert (pred message)
    "Asserts that the given predicate is true, otherwise fails"
    (if pred t (error message)))

(defun assert-not (pred message)
    "Asserts that the given predicate is false, otherwise fails"
    (if pred (error message) t))

(defun assert-eql (expected actual message)
    "Asserts the given values are equal, otherwise fails"
    (assert (eql expected actual) (format nil "Error: ~a: Expected ~a but received ~a" message expected actual)))

(defun assert-equal (expected actual message)
    "Asserts the given values are equal, otherwise fails"
    (assert (equal expected actual) (format nil "Error: ~a: Expected ~a but received ~a" message expected actual)))

(defun item-equality ()
    (assert (equal '(a b c) '(a b c)) "equivalent list")
    (assert (equal 'a 'a) "equivalent symbol")
    (assert-not (eq '(a b c) '(a b c)) "pointer non-equality list")
    (assert-not (eq 'a 'a) "pointer non-equality symbol")
    (let* ((l1 '(a b c)
           (l2 l1)))
        (assert (eq l1 l1) "pointer equality list")
        (assert (eq l1 l2) "pointer equality symbol"))
    ; not doing `eq` with numbers, because it's undefined
    (assert (eql 'a 'a) "eql symbol")
    (assert (eql "abcd" "abcd") "eql string")
    (assert (eql :abcd :abcd) "eql keyword")
    (assert-not (eql '(a b c) '(a b c)) "eql list")
    (assert (eql 15 15) "eql integer")
    (assert (eql 15.0 15.0) "eql float")
    (assert (eql (/ 1 2) (/ 3 6)) "eql ratio")
    (assert-not (eql 15 15.0) "not eql integer and float")
    (assert-not (eql 15.0 (/ 30 2)) "not eql float and ratio")
    (assert (= 15 15.0) "= int and float")
    (assert (= 15 (/ 30 2)) "= int and ratio")
    (assert (= 15.0 (/ 30 2)) "= float and ratio")
    (assert (equal "abcd" "abcd") "equal strings same case")
    (assert-not (equal "abcd" "ABCD") "not equal strings different case")
    (assert (equalp "abcd" "abcd") "equalp strings same case")
    (assert (equalp "abcd" "ABCD") "equalp strings different case")
)

(defun abs-and-sqrt ()
    (assert (eql 2 (abs 2)) "int abs pos")
    (assert (eql 2 (abs -2)) "int abs neg")
    (assert (eql 2.0 (abs 2.0)) "float abs pos")
    (assert (eql 2.0 (abs -2.0)) "float abs neg")
    (assert (eql (/ 1 2) (abs (/ 1 2))) "ratio abs pos")
    (assert (eql (/ 1 2) (abs (/ -1 2))) "ratio abs neg 1")
    (assert (eql (/ 1 2) (abs (/ 1 -2))) "ratio abs neg 2")
    (assert (eql 2.0 (sqrt 4)) "int sqrt")
    (assert (eql 2.0 (sqrt 4.0)) "float sqrt")
    (assert (eql 0.8 (sqrt (/ 16 25))) "ratio sqrt")
)

(defun short-circuit-and ()
    (assert-eql nil (and nil (undefined-function)) "short-circuit-and"))

(defun short-circuit-or ()
    (assert (or t (undefined-function)) "short-circuit-or"))

(defun built-in-predicates ()
    (assert
        (and     (symbolp 'a)
                 (symbolp :a)
            (not (symbolp 3))
                 (keywordp :a)
            (not (keywordp 'a))
                 (numberp 1)
            (not (numberp "one"))
                 (zerop 0)
            (not (zerop 1))
                 (plusp 1)
            (not (plusp 0))
                 (posnump 1)
            (not (posnump 0))
            (not (posnump 'x))
                 (evenp 2)
            (not (evenp 3))
                 (oddp 1)
            (not (oddp 2))
                 (stringp "a")
            (not (stringp 1))
                 (listp '(1))
                 (listp ())
            (not (listp 4))
                 (consp '(1))
            (not (consp ()))
            (not (consp 4))
                 (streamp *terminal-io*)
                 (atom 4)
                 (atom ())
            (not (atom '(1))))
        "built-in-predicates"))

(defun nil-equality ()
    (assert-eql nil () "nil-equality 1")
    (assert-eql () nil "nil-equality 2"))

(defun list-helpers ()
    (setq l '(4 5 6))
    (assert-eql 3 (length l) "list length")
    (assert-eql 4 (first l) "list first")
    (assert-eql 5 (second l) "list second")
    (assert-eql 6 (third l) "list third")
    (assert-equal '(5 6) (rest l) "list rest")
    (assert-eql 4 (car l) "list car")
    (assert-eql nil (car ()) "() car")
    (assert-eql nil (cdr ()) "() cdr")
    (assert-eql nil (third ()) "() third")
    (assert-eql nil (third nil) "nil third")
    (assert-equal '(1) (cons 1 nil) "nil cons")
    (assert-equal '(1 2 3) (cons 1 '(2 3)) "list cons")
    (assert-equal '(1 2 3) (list 1 2 3) "create list")
    (assert-equal '(1 . 2) (cons 1 2) "dotted list")
    (assert-equal '(a b c d e f) (append '(a b c) '(d e f)) "append list")
    (assert-equal '(a b c . d) (append '(a b c) 'd) "append value")
    (assert-equal '(c b a) (reverse '(a b c)) "reverse list")
    (assert-equal '(a b c) (nthcdr 0 '(a b c)) "nthcdr 0")
    (assert-equal '(b c) (nthcdr 1 '(a b c)) "nthcdr 1")
    (assert-equal '(c) (nthcdr 2 '(a b c)) "nthcdr 2")
    (assert-eql nil (nthcdr 3 '(a b c)) "nthcdr 3")
    (assert-eql nil (nthcdr 4 '(a b c)) "nthcdr 4")
    (assert-equal '(c . d) (nthcdr 2 '(a b c . d)) "nthcdr 2 improper list")
    (assert-eql 'd (nthcdr 3 '(a b c . d)) "nthcdr 3 improper list")
    (assert-eql 'a (nth 0 '(a b c)) "nth 0")
    (assert-eql 'b (nth 1 '(a b c)) "nth 1")
    (assert-eql 'c (nth 2 '(a b c)) "nth 2")
    (assert-eql nil (nth 3 '(a b c)) "nth 3")
    (assert-equal '(c) (last '(a b c)) "last proper")
    (assert-eql nil (last nil) "last nil")
    (assert-equal '(c . d) (last '(a b c . d)) "last improper")
    (assert-equal '(b n n) (remove 'a '(b a n a n a)) "remove item")
    (assert-equal '(b a n a n a) (remove 'x '(b a n a n a)) "remove nothing")
    (assert-equal '(b n n a) (remove 'a '(b a n a n a) :count 2) "remove with :count")
    (assert-equal '(b n n a) (remove 'a '(b a n a n a) :count 2 :from-end) "remove with :count and empty :from-end")
    (assert-equal '(b n n a) (remove 'a '(b a n a n a) :count 2 :from-end nil) "remove with :count and nil :from-end")
    (assert-equal '(b a n n) (remove 'a '(b a n a n a) :count 2 :from-end t) "remove with :count and t :from-end")
    (assert-equal '(b a n n) (remove 'a '(b a n a n a) :count 2 :from-end 'a) "remove with :count and non-nil :from-end")
    (assert-equal '(1 2 3) (member 1 '(1 2 3)) "member first")
    (assert-equal '(2 3) (member 2 '(1 2 3)) "member second")
    (assert-equal '(3) (member 3 '(1 2 3)) "member third")
    (assert-eql nil (member 4 '(1 2 3)) "member none")
    (let* ((l1 '(a b c))
           (l2 '(d c a))
           (int (intersection l1 l2)))
        (assert-eql 2 (length int) "intersection length")
        (assert (member 'a int) "intersection 1a")
        (assert (member 'c int) "intersection 1c"))
    (assert-eql nil (intersection '(a b c) '(d e f)) "intersection 2")
    (let* ((l1 '(f h a))
           (l2 '(e f o l))
           (un (union l1 l2)))
        (assert-eql 6 (length un) "union length")
        (assert (member 'f un) "union 1-1")
        (assert (member 'h un) "union 1-2")
        (assert (member 'a un) "union 1-3")
        (assert (member 'e un) "union 1-4")
        (assert (member 'o un) "union 1-5")
        (assert (member 'l un) "union 1-6"))
    (let* ((l1 '(a b c d))
           (l2 '(b c))
           (sd (set-difference l1 l2)))
        (assert-eql 2 (length sd) "set-difference 1 length")
        (assert (member 'a sd) "set-difference 1-1")
        (assert (member 'd sd) "set-difference 1-2"))
    (assert-eql nil (set-difference '(a b) '(b a)) "set-difference 2")
    (assert-eql t (subsetp '(a i) '(a e i o u)) "subsetp 1")
    (assert-eql nil (subsetp '(a x) '(a e i o u)) "subsetp 2")
    (setf words
        '((one uno)
          (two dos)
          (three tres)
          (four quatro)))
    (assert-equal '(two dos) (assoc 'two words) "assoc 2")
    (assert-equal '(three tres) (assoc 'three words) "assoc 3")
    (assert-eql nil (assoc 'six words) "assoc 6")
    (setf words
        '((one . uno)
          (two . dos)
          (three . tres)
          (four . quatro)))
    (assert-equal '(two . dos) (rassoc 'dos words) "rassoc 2")
    (assert-equal '(three . tres) (rassoc 'tres words) "rassoc 3")
    (assert-eql nil (rassoc 'seis words) "rassoc 6")
    (let* ((l1 '(a b d))
           (l2 '(b c d e))
           (ex (set-exclusive-or l1 l2)))
           (assert-eql 3 (length ex))
           (assert (member 'a ex) "set xor 1")
           (assert (member 'c ex) "set xor 2")
           (assert (member 'e ex) "set xor 3"))
    (assert-equal '(a b c) (remove-duplicates '(a a b b c b)) "remove-duplicates")
    (assert-equal '(x b c x b c d) (subst 'x 'a '(a b c a b c d)) "subst 1")
    (assert-equal '(e b c e b c d) (subst 'x 'a '(e b c e b c d)) "subst 2")
    (assert-equal () (subst 'x 'a ()) "subst 3")
    (assert-equal '(uno one-point-five dos) (sublis '((one . uno) (two . dos)) '(one one-point-five two)) "sublis")
    (assert-equal 7 (find-if #'oddp '(2 4 6 7 8 9)) "find-if")
    (assert-equal 9 (find-if #'oddp '(2 4 6 7 8 9) :from-end t) "find-if :from-end")
    (assert-equal '(2 4 6) (remove-if #'oddp '(1 2 3 4 5 6)) "remove-if")
    (assert-equal '(2 4 5 6) (remove-if #'oddp '(1 2 3 4 5 6) :count 2) "remove-if :count")
    (assert-equal '(1 3 5) (remove-if-not #'oddp '(1 2 3 4 5 6)) "remove-if-not")
    (assert-equal '(1 3 5 6) (remove-if-not #'oddp '(1 2 3 4 5 6) :count 2) "remove-if-not :count")
    (assert-equal 1 (reduce #'+ '(1)) "reduce single item")
    (assert-equal 10 (reduce #'+ '(1 2 3 4)) "reduce +")
    (assert-equal () (reduce #'+ nil) "reduce nil")
    (assert-equal '((((a . b) . c) . d) . e) (reduce #'cons '(a b c d e)) "reduce cons")
    (assert-equal '(a b c d . e) (reduce #'cons '(a b c d e) :from-end t) "reduce cons :from-end")
    (assert-equal t (every #'numberp '(1 2 3 4)) "every numberp")
    (assert-equal () (every #'numberp '(1 2 3 'A 'B 'C)) "every numberp false")
    (assert-equal t (every #'(lambda (x) (eql () x))) '(() () ()) "every with valid nil values")
    (assert-equal t (every #'> '(10 20 30 40) '(1 2 3 4)) "every with 2 arguments true")
    (assert-equal () (every #'> '(10 20 30 40) '(1 2 300 4)) "every with 2 arguments false")
    (assert-equal t (every #'(lambda (x y z) (and (numberp x) (numberp y) (numberp z))) '(10 20 30 40) '(1 2 3 4 5 6) '(1 2)) "every with 3 arguments true")
    (assert-equal () (every #'(lambda (x y z) (and (numberp x) (numberp y) (numberp z))) '(10 20 30 40) '(1 2 3 4 5 6) '(1 'B)) "every with 3 arguments false")
)

(defun common-helpers ()
    (assert-equal '(1 2) (quote (1 2)) "quote")
    (assert-eql 3 (eval '(+ 1 2)) "eval")
)

(defun format-tests ()
    (assert-equal "(1 a \"b\")" (format nil "~S" '(1 a "b")))
    (assert-equal "~" (format nil "~~" 1) "format tilde")
    (assert-equal "~~~~~~~~~~~~" (format nil "~12~" 1) "format lots of tildes")
)

(defun test-cond ()
    (assert-equal 'a (cond ((< 1 2) 'a)
                           ((not-a-function-and-will-error) 'b)) "cond only evals as far as necessary")
    (assert-equal 'b (cond ((< 2 1) 'a)
                           ((< 1 2) 'b)) "cond falls through to find proper value")
    (assert-eql () (cond ((< 2 1) 'a)
                         ((= 1 2) 'b)) "cond defaults to nil"))

(defun function-references ()
    (labels ((square (x) (* x x)))
            (assert-equal '(1 4 9) (mapcar #'square '(1 2 3)) "mapcar on named function reference"))
    (assert-equal '(1 4 9) (mapcar #'(lambda (n) (* n n)) '(1 2 3)) "mapcar on lambda function")
    (assert-equal '(3 6 9) (mapcar #'+ '(1 2 3) '(2 4 6 8)) "mapcar with multiple lists")
    (assert-equal 5 (funcall (function +) 2 3) "funcall with `function` keyword")
)

(and (item-equality)
     (abs-and-sqrt)
     (short-circuit-and)
     (short-circuit-or)
     (built-in-predicates)
     (nil-equality)
     (list-helpers)
     (common-helpers)
     (test-cond)
     (format-tests)
     (function-references)
)
